# RFC 6749 — The OAuth 2.0 Authorization Framework

> **発行**: IETF / 2012年10月 / **ステータス**: Proposed Standard
> **著者**: D. Hardt (Microsoft) / **更新**: RFC 6819, RFC 8252, RFC 8707 等

---

## 概要

RFC 6749 は **OAuth 2.0 Authorization Framework** を定義する IETF 標準仕様である。
サードパーティアプリケーションが、リソースオーナー（ユーザー）の認証情報を直接扱わずに、
保護されたリソースへの限定的なアクセス権を安全に委譲するための枠組みを提供する。

現代の Web/モバイルアプリケーションにおける「〇〇でログイン（Sign in with...）」や
API アクセス委譲の基盤として、事実上すべてのクラウドサービスに採用されている。

---

## 背景：なぜ OAuth 2.0 が必要だったか

OAuth 1.0（RFC 5849, 2010年）以前、サードパーティアプリが Twitter や Google のデータにアクセスするには、
ユーザーのパスワードを直接預かるしかなかった。これは：

- **パスワードの漏洩リスク** をサードパーティに拡散する
- アクセスを **細かく制限できない**（全か無か）
- ユーザーがアクセスを **個別に取り消せない**

という根本的な問題を抱えていた。

OAuth 1.0 はこれを解決したが、署名計算が複雑でクライアント実装の負荷が高く、
モバイルアプリや JavaScript クライアントへの適用が難しかった。
OAuth 2.0 は **TLS を前提とすることで署名を廃止**し、大幅にシンプルになった。

---

## 基本概念

### ロール（Roles）

| ロール | 説明 |
|--------|------|
| **Resource Owner** | 保護されたリソースへのアクセスを許可できるエンティティ（通常はエンドユーザー） |
| **Resource Server** | 保護されたリソースをホストするサーバー（API など）。Access Token を検証してリクエストに応答する |
| **Client** | Resource Owner の代わりにリソースへアクセスするアプリケーション |
| **Authorization Server** | Resource Owner を認証し、Access Token を発行するサーバー |

Resource Server と Authorization Server は同一サービスが兼ねることもあるが、
大規模システムでは別サービスとして分離する（例: Google の Auth サーバー vs API サーバー）。

### トークン

**Access Token**
Resource Server へのアクセスに使う短命なクレデンシャル。形式は仕様で規定されず、
不透明文字列（opaque string）でも JWT でも実装依存。有効期限は短く設定する（数分〜1時間程度）。

**Refresh Token**
Access Token の再発行に使うクレデンシャル。Authorization Server にのみ送信される。
有効期限は長い（数日〜数週間）。クライアントがオフライン時でも再認可不要でアクセスを継続できる。

### スコープ（Scope）

アクセス権の範囲を文字列で表す。複数スペース区切りで列挙する：

```
scope=read:profile write:posts
```

Authorization Server がスコープを解釈・制限し、Resource Server がアクセス判断に使う。

---

## グラントタイプ（認可フロー）

OAuth 2.0 は用途に応じた4つのグラントタイプを定義する。

### 1. Authorization Code Grant（認可コードグラント）

**最も推奨される汎用フロー**。ブラウザ経由でユーザーを Authorization Server にリダイレクトし、
認可コードを経由して Token を取得する。バックチャンネル（サーバー間通信）で Token を取得するため、
Token が URL に露出しない。

詳細は下節「Authorization Code フローの詳細」を参照。

### 2. Implicit Grant（暗黙的グラント）

ブラウザ上の JavaScript SPA 向けとして定義されたが、**現在は非推奨**（RFC 9700 にて）。
Access Token がブラウザの URL フラグメントに露出するため、ブラウザ履歴・Referer ヘッダーからの漏洩リスクがある。
PKCE 付き Authorization Code Grant に置き換えられた。

### 3. Resource Owner Password Credentials Grant（ROPCグラント）

クライアントがユーザーの ID・パスワードを直接受け取り、Token に交換するフロー。
OAuth 2.0 が解決しようとした「パスワード共有問題」に逆行するため、
**現在は非推奨**（RFC 9700 にて）。既存のレガシー認証からの移行用として定義された経緯がある。

### 4. Client Credentials Grant（クライアントクレデンシャルグラント）

ユーザーが関与しない **マシン間（M2M）通信**向け。クライアントが自身のクレデンシャル（ID + Secret）で
直接 Access Token を取得する。マイクロサービス間の API 認証やバックグラウンドジョブに使われる。

```
POST /token
  client_id=service-a&client_secret=xxx&grant_type=client_credentials&scope=api:read
```

---

## Authorization Code フローの詳細

現代の実装で中心となる Authorization Code Grant の全シーケンスを示す。

### シーケンス

```
User-Agent      Client            Authorization Server      Resource Server
    |               |                      |                       |
    |  1. アクセス  |                      |                       |
    |-------------->|                      |                       |
    |               |  2. 認可リクエスト   |                       |
    |               |  (リダイレクト)      |                       |
    |<--------------|                      |                       |
    |               |                      |                       |
    |  3. 認証・同意（ブラウザ上）         |                       |
    |------------------------------------->|                       |
    |                                      |                       |
    |  4. 認可コード付きリダイレクト       |                       |
    |<-------------------------------------|                       |
    |               |                      |                       |
    |  5. code 転送 |                      |                       |
    |-------------->|                      |                       |
    |               |  6. Token リクエスト |                       |
    |               |  (バックチャンネル)  |                       |
    |               |--------------------->|                       |
    |               |                      |                       |
    |               |  7. Access Token     |                       |
    |               |<---------------------|                       |
    |               |                      |                       |
    |               |  8. API コール                               |
    |               |  (Bearer Token)      |                       |
    |               |----------------------------------------------->|
    |               |                      |                       |
    |               |  9. レスポンス       |                       |
    |               |<-----------------------------------------------|
```

### ステップ 2：認可リクエスト

Client がユーザーを Authorization Server にリダイレクトする：

```
GET /authorize
  ?response_type=code
  &client_id=<CLIENT_ID>
  &redirect_uri=https://app.example.com/callback
  &scope=openid profile email
  &state=<RANDOM_STATE>
```

`state` は CSRF 攻撃対策のランダム値。Client が生成し、コールバック時に照合する。

### ステップ 4：認可レスポンス

ユーザーが同意後、Authorization Server はリダイレクト URI にコードを付与してリダイレクト：

```
GET /callback
  ?code=<AUTHORIZATION_CODE>
  &state=<SAME_STATE>
```

認可コードは**使い捨て**で有効期限は数分以内。

### ステップ 6：Token リクエスト（バックチャンネル）

Client のバックエンドサーバーから Authorization Server へ直接 POST：

```
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&code=<AUTHORIZATION_CODE>
&redirect_uri=https://app.example.com/callback
&client_id=<CLIENT_ID>
&client_secret=<CLIENT_SECRET>
```

### ステップ 7：Token レスポンス

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiJ9...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "tGzv3JOkF0XG5Qx2...",
  "scope": "openid profile email"
}
```

---

## セキュリティ上の重要な考慮事項

### PKCE（Proof Key for Code Exchange）— RFC 7636

Public Client（SPA・ネイティブアプリ）は `client_secret` を安全に保持できない。
そこで **PKCE** を用いる：

1. Client が `code_verifier`（ランダム文字列）を生成
2. `code_challenge = BASE64URL(SHA256(code_verifier))` を計算
3. 認可リクエストに `code_challenge` と `code_challenge_method=S256` を付加
4. Token リクエストに `code_verifier` を付加（Authorization Server が検証）

これにより、認可コードが傍受されても、`code_verifier` なしでは Token を取得できない。
**2023年以降、すべてのクライアントタイプで PKCE 適用が推奨**（BCP: OAuth 2.0 Security Best Current Practice）。

### state パラメータ

CSRF（クロスサイトリクエストフォージェリ）対策。認可リクエスト時にランダムな `state` を生成し、
コールバック時に照合する。不一致の場合はフローを中断する。

### redirect_uri の厳格なマッチング

Authorization Server は事前登録された redirect_uri と完全一致を要求すべき。
部分一致・ワイルドカードを許可すると open redirect 攻撃の起点になる。

### Token のスコープ最小化

クライアントは必要最小限のスコープのみリクエストする（最小権限の原則）。
ユーザーへの同意画面で過剰な権限を要求すると、同意疲労（consent fatigue）を招く。

---

## 後継・関連仕様

RFC 6749 は枠組みを定義するだけで、多くの詳細は後続仕様に委ねられている。

| 仕様 | 内容 |
|------|------|
| **RFC 7636** | PKCE — 認可コードインターセプト攻撃の対策 |
| **RFC 7662** | Token Introspection — RS が AS に Token を問い合わせるエンドポイント |
| **RFC 7009** | Token Revocation — Token 失効エンドポイント |
| **RFC 8693** | Token Exchange — あるトークンを別のトークンに変換 |
| **RFC 9068** | JWT Access Token — JWT 形式の Access Token の標準フォーマット |
| **RFC 9101** | JWT-Secured Authorization Request (JAR) — 認可リクエストの JWT 署名 |
| **RFC 9126** | Pushed Authorization Requests (PAR) — リクエストをバックチャンネル送信 |
| **RFC 9449** | DPoP — Sender-Constrained Access Token（Token バインディング） |
| **OpenID Connect Core 1.0** | OAuth 2.0 の上位に認証レイヤーを追加 |
| **FAPI 2.0** | 金融 API 向けの高セキュリティプロファイル（PKCE + PAR 必須など） |
| **OAuth 2.1** (draft) | RFC 6749 の改訂版。非推奨グラントを削除し PKCE を必須化 |

### OAuth 2.1 について

現在 IETF で策定中の OAuth 2.1（draft-ietf-oauth-v2-1）は、RFC 6749 の「合理化版」である。
主な変更点：

- Implicit Grant **削除**
- ROPC Grant **削除**
- PKCE **必須化**（すべてのグラントタイプ）
- Bearer Token の安全な使用要件の明文化
- redirect_uri の完全一致を要求

新規実装では事実上 OAuth 2.1 相当のプラクティスが推奨されており、
RFC 6749 は「参照仕様」として残るが、実装の指針は OAuth 2.1 ドラフトと BCP 212（RFC 9700）に移行しつつある。

---

## 実装状況・採用

RFC 6749 は 2012年の発行から12年以上経過し、現代インターネットの基盤インフラとなっている。

**主要な Authorization Server 実装**

- **クラウド**: Google Identity Platform, Microsoft Entra ID (Azure AD), AWS Cognito, Okta, Auth0
- **OSS**: Keycloak, Hydra (ORY), Spring Authorization Server, Authelia, Zitadel
- **プログラミング言語**: 主要言語すべてにクライアントライブラリが存在

**採用パターン**

- Web/モバイルアプリの「ソーシャルログイン」基盤
- Enterprise SaaS の SSO（Single Sign-On）
- マイクロサービス間 API 認証（Client Credentials Grant）
- IoT デバイス認証（Device Authorization Grant: RFC 8628）

---

## 読み解きのポイント

RFC 6749 を最初に読む際に意識すると理解が深まる点をまとめる。

**「認可」であって「認証」ではない**
OAuth 2.0 は**アクセス権の委譲**を扱う仕様であり、ユーザーの**認証**（本人確認）は仕様外である。
「OAuth でログイン」という表現は不正確で、認証が必要なら OpenID Connect を組み合わせる。

**Access Token の形式は規定されない**
RFC 6749 は Access Token の内部形式を定義しない。JWT にするか不透明文字列にするかは実装次第。
JWT Access Token の標準フォーマットは RFC 9068 が別途定義する。

**スコープの意味論は各 AS が定義する**
`read`, `write`, `openid`, `profile` などのスコープ名の解釈は Authorization Server ごとに異なる。
共通の意味論を持つのは OpenID Connect スコープ（`openid`, `profile`, `email` 等）のみ。

---

## 参考

- [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749)
- [RFC 7636: PKCE](https://www.rfc-editor.org/rfc/rfc7636)
- [RFC 9700: OAuth 2.0 Security Best Current Practice](https://www.rfc-editor.org/rfc/rfc9700)
- [OAuth 2.1 (draft-ietf-oauth-v2-1)](https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/)
- [OAuth 2.0 Threat Model and Security Considerations: RFC 6819](https://www.rfc-editor.org/rfc/rfc6819)
